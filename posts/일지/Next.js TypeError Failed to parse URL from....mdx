---
title: Next.js TypeError Failed to parse URL from...
description: next 사용 중 발생한 에러에 대해 기술한다.
tags:
  - next
  - bugs
createdAt: 2025-10-29
thumbnail: /thumbnails/bugs.webp
draft: true
---
## 서론

next를 통해서 개발하던 도중 다음과 같은 문구를 만나게 됐다.

```bash
TypeError: Failed to parse URL from api/users/search?...
```
next의 `Route Handler`를 통해 api를 호출하던 도중 생긴 문제이다. 나는 다음과 같은 코드로 api를 호출하고 있었다.

```tsx
// api/lib/api.ts

export async function apiGet<T>(url: string): Promise<T> {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`API ERROR : ${res.status}`);
  return res.json();
}

export const API = {
  async searchUser(username: string) {
    return apiGet<UserResponse>(
      `/api/users/search?username=${username}`
    );
  },
};
...

// page.tsx
...
	const resp = await API.searchUser(username); // error
	
```
`lib/api.ts`에서 API wrapper와 API 객체를 export하고 page에서 이를 사용하는 식이었다. 당연히 `api/users/search/route.ts`에서 해당 api를 정의하고 있었다. 

그리고 이 에러의 가장 큰 문제가 있었는데....

바로 **기존에 동작하던 코드**라는 점이었다.

## 기존 방식

기존에는 무엇이 달랐던 걸까? 바로 기존의 `page.tsx`는 **클라이언트 컴포넌트** 였다는 사실이다.

```tsx
// page.tsx
...
	useEffect(()=>{
		const getUser = async()=>{
			const resp = await API.searchUser(username);
			...
			};
		getUser();
		}
	},[])
```
위 코드가 처음에 API를 호출하던 방식이었다. 하지만 `page`를 **서버 컴포넌트**로 바꾸면서 에러가 발생한 것이다.

## 신규 방식

```tsx
export default async function Page({
  params,
}: {
  params: { username: string };
}){
	const { username } = await params;
	const resp = await API.searchUser(username); // error
}
```
위 코드처럼 기존 코드를 서버 컴포넌트로 바꾸자 에러가 발생하였다. 

## 분석

처음에는 도저히 이유를 찾지 못했다. 하지만 이유를 알게 되니 너무나 당연한 이유였다. 이유는 바로 

>서버 컴포넌트는 서버 환경에서 동작한다.

였다! 

> 엥? 서버에서 동작하니까 서버 컴포넌트지. 이게 무슨 이유라는 거임?

당연한 의문이다. 하지만 이는 Server Component의 환경에서 가능한 일과 불가능 한 일을 생각하지 않았기 때문이다.

## React Server Component

React 18에서 등장한 React Server Component (이하 RSC )는 서버에서 렌더링되는 컴포넌트이다. 따라서 RSC가 알 수 있는 것과, 알 수 없는 것이 명확히 구분된다.

### 알 수 있다

서버에서 실행되기에, Node.js 런타임 수준의 정보와 리소스에 접근 가능하다.

1. 환경 변수
2. 파일 시스템
	1. 서버 로컬 파일 읽기 가능
	2. fs 모듈
3. 서버 측 로직
4. 데이터베이스 / 외부 API 등
5. 빌드 타임에 결정되는 환경 정보

### 알 수 없다

서버에서 실행되기에, **브라우저 환경**에서만 존재하는 정보나 요청 컨텍스트에 의존하는 데이터는 기본적으로 알 수 없다.

1. 클라이언트 요청 정보
	- 사용자 IP, host, 쿠키 등
	- 단, next에서 `headers()`,`coockies()` 등으로 접근 가능
2. 브라우저 관련 객체
	- `window`,`document`,`localstorage`등 불가능
3. 동적 클라이언트 상태

## 결론

따라서, Server Component 로 변경된 `page`에서는 클라이언트의 실행 환경의 `host`명을 알 수 없기에, 요청 경로인 `/api/users/...`의 호스트를 알 수 없어서 생긴 오류인 것이다. 

## 해결

근본적으로 요청 API의 baseURL을 추가하는 것으로 해결하였다.

```typescript
export async function apiGet<T>(url: string): Promise<T> {
  const API_BASE_URL = process.env.API_BASE_URL; // 추가
  const res = await fetch(API_BASE_URL + url);
  if (!res.ok) throw new Error(`API ERROR : ${res.status}`);
  
  return res.json();
}
```



## 참고 자료


